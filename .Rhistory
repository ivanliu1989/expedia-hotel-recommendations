cn <- connect(host='localhost', db='comtrade_source', user='sa', pass='Servian1', platform="mac")
library(RODBC)
### function ###
connect <- function(host, db, user=NULL, pass=NULL, platform="win" ){
# TODO: Check input paramaters and add a branch for SQL auth on windows
if(platform == "win"){
c <- odbcDriverConnect(connection=paste0("server=",host,";database=",db,
";trusted_connection=true;Port=1433;driver={SQL Server};TDS_Version=7.0;"))
if(class(c) == 'RODBC'){
writeLines("Successfilly opened connection to db")
return(c)
}else{
writeLines(paste0("Error opening connection: ", as.character(c)))
}
}
if(platform == "mac"){
c <- odbcDriverConnect(connection=paste0("server=",host,";database=",db,";uid=",user,";pwd=",pass,
";Port=1433;driver=FreeTDS;TDS_Version=7.0;"))
if(class(c) == 'RODBC'){
writeLines("Successfilly opened connection to db")
return(c)
}else{
writeLines(paste0("Error opening connection: ", as.character(c)))
}
}
}
# rdp.csgplatform.com:5685
cn <- connect(host='localhost', db='comtrade_source', user='sa', pass='Servian1', platform="mac")
install.packages('RODBC')
install.packages("RODBC")
cn <- connect(host='localhost', db='comtrade_source', user='sa', pass='Servian1', platform="mac")
library(RODBC)
cn <- connect(host='localhost', db='comtrade_source', user='sa', pass='Servian1', platform="mac")
#load ODBC library
library(RODBC)
# #load data
# data <- sqlFetch(cn, 'myTable', colnames=FALSE, rows_at_time=1000)
# #load data
# data <- sqlQuery(cn, "select * from myTable")
# status <- sqlGetResults(cn, as.is = FALSE, errors = TRUE, max = 0, buffsize = 1000000,
#                         nullstring = NA_character_, na.strings = "NA", believeNRows = TRUE, dec = getOption("dec"),
#                         stringsAsFactors = default.stringsAsFactors())
# #read with odbcQuery
# status  <- odbcQuery(cn, "select * from myTable")
# data <- odbcFetchRows(cn, max = 0, buffsize = 10000, nullstring = NA_character_, believeNRows = TRUE)
# error <- odbcGetErrMsg(cn)
### function ###
connect <- function(host, db, user=NULL, pass=NULL, platform="win" ){
# TODO: Check input paramaters and add a branch for SQL auth on windows
if(platform == "win"){
c <- odbcDriverConnect(connection=paste0("server=",host,";database=",db,
";trusted_connection=true;Port=1433;driver={SQL Server};TDS_Version=7.0;"))
if(class(c) == 'RODBC'){
writeLines("Successfilly opened connection to db")
return(c)
}else{
writeLines(paste0("Error opening connection: ", as.character(c)))
}
}
if(platform == "mac"){
c <- odbcDriverConnect(connection=paste0("server=",host,";database=",db,";uid=",user,";pwd=",pass,
";Port=1433;driver=FreeTDS;TDS_Version=7.0;"))
if(class(c) == 'RODBC'){
writeLines("Successfilly opened connection to db")
return(c)
}else{
writeLines(paste0("Error opening connection: ", as.character(c)))
}
}
}
# rdp.csgplatform.com:5685
cn <- connect(host='localhost', db='comtrade_source', user='sa', pass='Servian1', platform="mac")
cn <- connect(host='localhost', db='comtrade_source', user='sa', pass='Servian1', platform="mac")
cn <- connect(host='localhost', db='comtrade_source', user='sa', pass='Servian1', platform="mac")
library(RODBC)
library(RODBC)
odbcDataSources()
connect <- function(host, db, user=NULL, pass=NULL, platform="win" ){
# TODO: Check input paramaters and add a branch for SQL auth on windows
if(platform == "win"){
c <- odbcDriverConnect(connection=paste0("server=",host,";database=",db,
";trusted_connection=true;Port=1433;driver={SQL Server};TDS_Version=7.0;"))
if(class(c) == 'RODBC'){
writeLines("Successfilly opened connection to db")
return(c)
}else{
writeLines(paste0("Error opening connection: ", as.character(c)))
}
}
if(platform == "mac"){
c <- odbcDriverConnect(connection=paste0("server=",host,";database=",db,";uid=",user,";pwd=",pass,
";Port=1433;driver=FreeTDS;TDS_Version=7.0;"))
if(class(c) == 'RODBC'){
writeLines("Successfilly opened connection to db")
return(c)
}else{
writeLines(paste0("Error opening connection: ", as.character(c)))
}
}
}
# rdp.csgplatform.com:5685
cn <- connect(host='localhost', db='comtrade_source', user='sa', pass='Servian1', platform="mac")
library(RODBC)
odbcDriverConnect()
odbcDataSources()
#load ODBC library
library(RODBC)
odbcDataSources()
# #load data
# data <- sqlFetch(cn, 'myTable', colnames=FALSE, rows_at_time=1000)
# #load data
# data <- sqlQuery(cn, "select * from myTable")
# status <- sqlGetResults(cn, as.is = FALSE, errors = TRUE, max = 0, buffsize = 1000000,
#                         nullstring = NA_character_, na.strings = "NA", believeNRows = TRUE, dec = getOption("dec"),
#                         stringsAsFactors = default.stringsAsFactors())
# #read with odbcQuery
# status  <- odbcQuery(cn, "select * from myTable")
# data <- odbcFetchRows(cn, max = 0, buffsize = 10000, nullstring = NA_character_, believeNRows = TRUE)
# error <- odbcGetErrMsg(cn)
### function ###
connect <- function(host, db, user=NULL, pass=NULL, platform="win" ){
# TODO: Check input paramaters and add a branch for SQL auth on windows
if(platform == "win"){
c <- odbcDriverConnect(connection=paste0("server=",host,";database=",db,
";trusted_connection=true;Port=1433;driver={SQL Server};TDS_Version=7.0;"))
if(class(c) == 'RODBC'){
writeLines("Successfilly opened connection to db")
return(c)
}else{
writeLines(paste0("Error opening connection: ", as.character(c)))
}
}
if(platform == "mac"){
c <- odbcDriverConnect(connection=paste0("server=",host,";database=",db,";uid=",user,";pwd=",pass,
";Port=1433;driver=FreeTDS;TDS_Version=7.0;"))
if(class(c) == 'RODBC'){
writeLines("Successfilly opened connection to db")
return(c)
}else{
writeLines(paste0("Error opening connection: ", as.character(c)))
}
}
}
# rdp.csgplatform.com:5685
cn <- connect(host='localhost', db='comtrade_source', user='sa', pass='Servian1', platform="mac")
#load ODBC library
library(RODBC)
odbcDataSources()
# #load data
# data <- sqlFetch(cn, 'myTable', colnames=FALSE, rows_at_time=1000)
# #load data
# data <- sqlQuery(cn, "select * from myTable")
# status <- sqlGetResults(cn, as.is = FALSE, errors = TRUE, max = 0, buffsize = 1000000,
#                         nullstring = NA_character_, na.strings = "NA", believeNRows = TRUE, dec = getOption("dec"),
#                         stringsAsFactors = default.stringsAsFactors())
# #read with odbcQuery
# status  <- odbcQuery(cn, "select * from myTable")
# data <- odbcFetchRows(cn, max = 0, buffsize = 10000, nullstring = NA_character_, believeNRows = TRUE)
# error <- odbcGetErrMsg(cn)
### function ###
connect <- function(host, db, user=NULL, pass=NULL, platform="win" ){
# TODO: Check input paramaters and add a branch for SQL auth on windows
if(platform == "win"){
c <- odbcDriverConnect(connection=paste0("server=",host,";database=",db,
";trusted_connection=true;Port=1433;driver={SQL Server};TDS_Version=7.0;"))
if(class(c) == 'RODBC'){
writeLines("Successfilly opened connection to db")
return(c)
}else{
writeLines(paste0("Error opening connection: ", as.character(c)))
}
}
if(platform == "mac"){
c <- odbcDriverConnect(connection=paste0("server=",host,";database=",db,";uid=",user,";pwd=",pass,
";Port=1433;driver=FreeTDS;TDS_Version=7.0;"))
if(class(c) == 'RODBC'){
writeLines("Successfilly opened connection to db")
return(c)
}else{
writeLines(paste0("Error opening connection: ", as.character(c)))
}
}
}
# rdp.csgplatform.com:5685
cn <- connect(host='localhost', db='comtrade_source', user='sa', pass='Servian1', platform="mac")
ch1 <- odbcConnect(dsn="sqlserver01", uid="sa", pwd="Servian1")
ch1 <- odbcConnect(dsn="sqlserver01", uid="sa", pwd="Servian1")
#load ODBC library
library(RODBC)
odbcDataSources()
ch1 <- odbcConnect(dsn="sqlserver01", uid="sa", pwd="Servian1")
# #load data
# data <- sqlFetch(cn, 'myTable', colnames=FALSE, rows_at_time=1000)
# #load data
# data <- sqlQuery(cn, "select * from myTable")
# status <- sqlGetResults(cn, as.is = FALSE, errors = TRUE, max = 0, buffsize = 1000000,
#                         nullstring = NA_character_, na.strings = "NA", believeNRows = TRUE, dec = getOption("dec"),
#                         stringsAsFactors = default.stringsAsFactors())
# #read with odbcQuery
# status  <- odbcQuery(cn, "select * from myTable")
# data <- odbcFetchRows(cn, max = 0, buffsize = 10000, nullstring = NA_character_, believeNRows = TRUE)
# error <- odbcGetErrMsg(cn)
### function ###
connect <- function(host, db, user=NULL, pass=NULL, platform="win" ){
# TODO: Check input paramaters and add a branch for SQL auth on windows
if(platform == "win"){
c <- odbcDriverConnect(connection=paste0("server=",host,";database=",db,
";trusted_connection=true;Port=1433;driver={SQL Server};TDS_Version=7.0;"))
if(class(c) == 'RODBC'){
writeLines("Successfilly opened connection to db")
return(c)
}else{
writeLines(paste0("Error opening connection: ", as.character(c)))
}
}
if(platform == "mac"){
c <- odbcDriverConnect(connection=paste0("server=",host,";database=",db,";uid=",user,";pwd=",pass,
";Port=1433;driver=FreeTDS;TDS_Version=7.0;"))
if(class(c) == 'RODBC'){
writeLines("Successfilly opened connection to db")
return(c)
}else{
writeLines(paste0("Error opening connection: ", as.character(c)))
}
}
}
# rdp.csgplatform.com:5685
cn <- connect(host='localhost', db='comtrade_source', user='sa', pass='Servian1', platform="mac")
ch1 <- odbcConnect(dsn="sqlserver01", uid="sa", pwd="Servian1")
require(Rserve)
Rserve()
Rserve()
install.packages(c("boot", "gtools", "manipulate"))
head(train)
rm(list = ls()); gc()
require(data.table);require(caret);require(doMC);require(ROCR)
registerDoMC(core=3)
load('data/new/cv_data_log_extend.RData')
install.packages("manipulate")
data("iris")
# this is a little tweak so that things line up nicely later on
iris$Species <- factor(iris$Species,
levels = c("versicolor","virginica","setosa"))
head(iris)
ound(cor(iris[,1:4]), 2)
round(cor(iris[,1:4]), 2)
pc <- princomp(iris[,1:4], cor=TRUE, scores=TRUE)
pc
summary(pc)
plot(pc,type="lines")
biplot(pc)
library(rgl)
plot3d(pc$scores[,1:3], col=iris$Species)
plot3d(pc$scores[,1:3], col=iris$Species)
plot3d(pc$scores[,1:3])#, col=iris$Species)
text3d(pc$scores[,1:3],texts=rownames(iris))
text3d(pc$loadings[,1:3], texts=rownames(pc$loadings), col="red")
coords <- NULL
for (i in 1:nrow(pc$loadings)) {
coords <- rbind(coords, rbind(c(0,0,0),pc$loadings[i,1:3]))
}
for (i in 1:nrow(pc$loadings)) {
coords <- rbind(coords, rbind(c(0,0,0),pc$loadings[i,1:3]))
}
lines3d(coords, col="red", lwd=4)
set.seed(42)
cl <- kmeans(iris[,1:4],3)
iris$cluster <- as.factor(cl$cluster)
plot3d(pc$scores[,1:3], col=iris$cluster, main="k-means clusters")
plot3d(pc$scores[,1:3], col=iris$Species, main="actual species")
with(iris, table(cluster, Species))
data("iris")
# this is a little tweak so that things line up nicely later on
iris$Species <- factor(iris$Species,
levels = c("versicolor","virginica","setosa"))
head(iris)
round(cor(iris[,1:4]), 2)
pc <- princomp(iris[,1:4], cor=TRUE, scores=TRUE)
summary(pc)
plot(pc,type="lines")
biplot(pc)
library(rgl)
plot3d(pc$scores[,1:3], col=iris$Species)
text3d(pc$scores[,1:3],texts=rownames(iris))
text3d(pc$loadings[,1:3], texts=rownames(pc$loadings), col="red")
coords <- NULL
for (i in 1:nrow(pc$loadings)) {
coords <- rbind(coords, rbind(c(0,0,0),pc$loadings[i,1:3]))
}
lines3d(coords, col="red", lwd=4)
set.seed(42)
cl <- kmeans(iris[,1:4],3)
iris$cluster <- as.factor(cl$cluster)
plot3d(pc$scores[,1:3], col=iris$cluster, main="k-means clusters")
A <- matrix(c(1,2,3,4),nrow = 2, byrow = T)
B <- matrix(c(3,4,5,6),nrow = 2, byrow = T)
a <- c(1,2)
b <- c(2,3)
diag(10)
A
B
A*B
A%*%B
A%o%B # AB' A%*%t(B)
crossprod(A,B) # A'B  t(A)%*%A
crossprod(A) # A'A
b
solve(A,b) # A%*%solve(A,b)
solve(A,a) # A%*%solve(A,b)
a <- c(1200:1300)
a
b <- seq(15,100,5)
b
a/b
c <- a/b
c
a/15
apply(b, f(x) a/x)
apply(b, f(x){a/x})
sapply(b, f(x){a/x})
sapply(b, f(x){a/x})
lapply(b, f(x){a/x})
lapply(b, f(x)a/x)
lapply(b, f(x) a/x)
lapply(b,
f(x){
a/x
}
)
?sapply
b
sapply(b, a/x)
sapply(b, mean)
sapply(b, function(x) a/x)
a
x <− c ( 9 : 2 0 , 1 : 5 , 3 : 7 , 0 : 8 )
x <- c( 9 : 2 0 , 1 : 5 , 3 : 7 , 0 : 8 )
x <- c(9:20,1:5,3:7,0:8)
x
(xu<-x[!duplicated(x)])
unique ( x ) # i s more e f f i c i e n t
x[!duplicated(x)]
gc()
?setdiff
(x <- c(sort(sample(1:20, 9)), NA))
(y <- c(sort(sample(3:23, 7)), NA))
union(x, y)
intersect(x, y)
setdiff(y, x)
setequal(x, y)
library(xgboost)
?xgb.train
setwd('/Users/ivanliu/Downloads/Expedia_kaggle/expedia-hotel-recommendations')
library(data.table)
train <- fread('../data/train.csv')
test <- fread('../data/test.csv')
destination <- fread('../data/destinations.csv')
submit <- fread('../data/sample_submission.csv')
leaky_cols <- c('user_location_country', 'user_location_region', 'user_location_city', 'hotel_market', 'orig_destination_distance')
target_col <- 'hotel_cluster'
train
train[,cnt := 1]
?aggregate
train[,leaky_1 := .N, by = leaky_cols]
leaky_cols_2 <- c('user_location_city', 'orig_destination_distance')
train[,leaky_1 := .N, by = c(leaky_cols,target_col)]
train[,leaky_1 := .N, by = c(leaky_cols,target_col)]
train
train[,leaky_1 := .N, by = c(leaky_cols,target_col)]
train[,leaky_2 := .N, by = c(leaky_cols,target_col)]
train_leaky <- train[,.(user_location_country, user_location_region, user_location_city, hotel_market,
orig_destination_distance, hotel_cluster, leaky_1, leaky_2)]
train_leaky
setkey(train_leaky)
unique(train_leaky)
train_leaky
train_leaky <- unique(train_leaky)
train_leaky
train_leaky[!is.na(orig_destination_distance)]
train_leaky
train_leaky <- train_leaky[!is.na(orig_destination_distance)]
train_leaky
test_leaky
test
train
train[,cnt := 1]
train[,leaky_1 := .N, by = c(leaky_cols,'is_booking',target_col)]
train[,leaky_2 := .N, by = c(leaky_cols,'is_booking',target_col)]
train_leaky <- train[,.(user_location_country, user_location_region, user_location_city, hotel_market,
orig_destination_distance, hotel_cluster, is_booking, leaky_1, leaky_2)]
setkey(train_leaky)
train_leaky <- unique(train_leaky)
train_leaky <- train_leaky[!is.na(orig_destination_distance)]
train_leaky
test_leaky <- test[,.(user_location_country, user_location_region, user_location_city, hotel_market,
orig_destination_distance, hotel_cluster, is_booking, leaky_1, leaky_2)]
test_leaky <- test[,.(user_location_country, user_location_region, user_location_city, hotel_market,
orig_destination_distance)]
test_leaky <- test[,.(user_location_country, user_location_region, user_location_city, hotel_market, orig_destination_distance)]
test_leaky
submit
test
test_leaky <- test[,.(id, user_location_country, user_location_region, user_location_city, hotel_market, orig_destination_distance)]
test_leaky
train_leaky
train_leaky_1 <- train_leaky[is_booing == 1]
train_leaky
train_leaky_1 <- train_leaky[is_booking == 1]
train_leaky_1
train_leaky_1 <- train_leaky_1[, is_booking = NULL]
train_leaky_1 <- train_leaky_1[, is_booking := NULL]
train_leaky_1
test_leaky
setkey(train_leaky_1, c('user_location_country', 'user_location_region', 'user_location_city', 'hotel_market', 'orig_destination_distance', 'hotel_cluster'))
train_leaky_1
setkey(train_leaky_1, c('user_location_country', 'user_location_region', 'user_location_city', 'hotel_market', 'orig_destination_distance', 'hotel_cluster'))
train_leaky_1[base:::order(user_location_country, user_location_region, user_location_city, hotel_market, orig_destination_distance, -hotel_cluster)]
train_leaky_1 <- train_leaky_1[base:::order(user_location_country, user_location_region, user_location_city, hotel_market, orig_destination_distance, -hotel_cluster)]
library(tidyr)
?spread
spread(train_leaky_1, hotel_cluster, leaky_1)
test
test_leaky
r=1
test_leaky[r,user_location_country]
res <- train_leaky_1[user_location_city == test_leaky[r,user_location_city] & orig_destination_distance == test_leaky[r,orig_destination_distance]]
res
is.na(res)
nrow(res)
test_leaky[,hotel_cluster_1 := NA]
test_leaky
test_leaky[,hotel_cluster_1 := NA]
test_leaky[,hotel_cluster_1 := NA]for(r in 1:nrow(test_leaky)){
test_leaky[,hotel_cluster_2 := NA]
test_leaky[,hotel_cluster_3 := NA]
test_leaky[,hotel_cluster_4 := NA]
test_leaky[,hotel_cluster_5 := NA]
test_leaky
i=1
test_leaky[r, 6+i]
test_leaky[r, 6+i, with = FALSE]
test_leaky[r, 6+i, with = FALSE] <- 1
test_leaky[r, 6+i := 1, with = FALSE]
test_leaky[r, 6+i = 1, with = FALSE]
res <- data.frame(id = -1, hotel_cluster_1 = -1, hotel_cluster_2 = -1, hotel_cluster_3 = -1, hotel_cluster_4 = -1, hotel_cluster_5 = -1)
res
test_leaky[r, id]
train_leaky_1
c(test_leaky[r, id], res[leaky_1])
res <- train_leaky_1[user_location_city == test_leaky[r,user_location_city] & orig_destination_distance == test_leaky[r,orig_destination_distance]]
res
r=2
res <- train_leaky_1[user_location_city == test_leaky[r,user_location_city] & orig_destination_distance == test_leaky[r,orig_destination_distance]]
res
test_leaky[r,user_location_city]
res[hotel_cluster]
res <- data.frame(id = -1, hotel_cluster_1 = -1, hotel_cluster_2 = -1, hotel_cluster_3 = -1, hotel_cluster_4 = -1, hotel_cluster_5 = -1)
for(r in 1:nrow(test_leaky)){
res <- train_leaky_1[user_location_city == test_leaky[r,user_location_city] & orig_destination_distance == test_leaky[r,orig_destination_distance]]
if(nrow(res)>0){
res <- rbind(res, c(test_leaky[r, id], res[hotel_cluster]))
cat(paste0(res[hotel_cluster], ' /n', res[leaky_1], ' /n'))
}
}
train_leaky_1
nrow(train_leaky_1)
res <- data.frame(id = -1, hotel_cluster_1 = -1, hotel_cluster_2 = -1, hotel_cluster_3 = -1, hotel_cluster_4 = -1, hotel_cluster_5 = -1)
for(r in 1:nrow(test_leaky)){
res <- train_leaky_1[user_location_city == test_leaky[r,user_location_city] & orig_destination_distance == test_leaky[r,orig_destination_distance]]
if(nrow(res)>0){
res <- rbind(res, c(test_leaky[r, id], res[,hotel_cluster]))
cat(paste0(res[,hotel_cluster], ' /n', res[,leaky_1], ' /n'))
}
}
res
res[,hotel_cluster]
c(test_leaky[r, id], res[,hotel_cluster])
rbind(res, c(test_leaky[r, id], res[,hotel_cluster]))
res
res <- data.frame(id = -1, hotel_cluster_1 = -1, hotel_cluster_2 = -1, hotel_cluster_3 = -1, hotel_cluster_4 = -1, hotel_cluster_5 = -1)
as.data.frame(c(test_leaky[r, id], res[,hotel_cluster]))
c(test_leaky[r, id], res[,hotel_cluster])
predict <- data.frame(id = -1, hotel_cluster_1 = -1, hotel_cluster_2 = -1, hotel_cluster_3 = -1, hotel_cluster_4 = -1, hotel_cluster_5 = -1)
for(r in 1:nrow(test_leaky)){
res <- train_leaky_1[user_location_city == test_leaky[r,user_location_city] & orig_destination_distance == test_leaky[r,orig_destination_distance]]
if(nrow(res)>0){
predict <- rbind(predict, as.data.frame(c(test_leaky[r, id], res[,hotel_cluster])))
cat(paste0(res[,hotel_cluster], ' /n', res[,leaky_1], ' /n'))
}
}
as.data.frame(c(test_leaky[r, id], res[,hotel_cluster]))
c(test_leaky[r, id], res[,hotel_cluster])
res[2,hotel_cluster]
c(test_leaky[r, id], res[1,hotel_cluster], res[2,hotel_cluster], res[3,hotel_cluster], res[4,hotel_cluster], res[5,hotel_cluster])
predict <- rbind(predict, c(test_leaky[r, id], res[1,hotel_cluster], res[2,hotel_cluster], res[3,hotel_cluster], res[4,hotel_cluster], res[5,hotel_cluster]))
predict
predict <- data.frame(id = -1, hotel_cluster_1 = -1, hotel_cluster_2 = -1, hotel_cluster_3 = -1, hotel_cluster_4 = -1, hotel_cluster_5 = -1)
for(r in 1:nrow(test_leaky)){
res <- train_leaky_1[user_location_city == test_leaky[r,user_location_city] & orig_destination_distance == test_leaky[r,orig_destination_distance]]
if(nrow(res)>0){
predict <- rbind(predict, c(test_leaky[r, id], res[1,hotel_cluster], res[2,hotel_cluster], res[3,hotel_cluster], res[4,hotel_cluster], res[5,hotel_cluster]))
cat(paste0(r, ': ', res[,hotel_cluster], ' /n', res[,leaky_1], ' /n'))
}
}
predict <- data.frame(id = -1, hotel_cluster_1 = -1, hotel_cluster_2 = -1, hotel_cluster_3 = -1, hotel_cluster_4 = -1, hotel_cluster_5 = -1)
for(r in 1:nrow(test_leaky)){
res <- train_leaky_1[user_location_city == test_leaky[r,user_location_city] & orig_destination_distance == test_leaky[r,orig_destination_distance]]
if(nrow(res)>0){
predict <- rbind(predict, c(test_leaky[r, id], res[1,hotel_cluster], res[2,hotel_cluster], res[3,hotel_cluster], res[4,hotel_cluster], res[5,hotel_cluster]))
cat(paste0(r, ': ', res[,hotel_cluster], ' \n', res[,leaky_1], ' \n'))
}
}
